#!/usr/bin/env python
# run_rmg_alt
# Alternative script for running RMG module. This was written to eliminate 
# all possible complexity in the code in order to identify bottleneck in 
# the signal processing that was causing the USRP buffer to overflow 
# ("00000 ... 00" appear in stderr). We instantiate only the necessary 
# components of the graph and fix the number of channels and detectors 
# (nchan and nbank respectively).

# This file is part of QRAAT, an automated animal tracking system 
# based on GNU Radio. 
#
# Copyright (C) 2012 Todd Borrowman, Christopher Patton
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from gnuradio import gr, blks2, uhd, gru
from rmg import *
import shelve

USE_PSD = 1 #1 to use pulse_shape_detector in pulse detector, 0 to not use it
nchan = 4
nbank = 32

class Detector(gr.top_block): 

  def __init__(self, serial="/dev/ttyS0", fpga_frequency = -10.7e6, decim_factor = 250):
    gr.top_block.__init__(self)
    
    # connect to RMG via serial port
    try:
      self.sc = rmg_pic_interface.rmg_pic_interface(serial)
    except IOError:
      print "Couldn't connect to RMG on " + serial
      raise SystemExit
  
    # load tuning parameters
    self.__load_param('tx.csv')
    param = self.backend_param

    print "initializing USRP" 
    self.u = uhd.usrp_source(device_addr="fpga=usrp1_fpga_4rx.rbf", stream_args=uhd.stream_args('fc32', channels=range(nchan)))
    self.u.set_subdev_spec("A:A A:B B:A B:B")
    self.usrp_rate = self.u.get_clock_rate()
    self.usb_rate = self.usrp_rate / decim_factor
    self.u.set_samp_rate(self.usb_rate)

    print "creating filter bank" 
    #calculate the filter for the polyphase filter
    band_rate = param.bw
    print "Band sampling rate :",band_rate
    taps = gr.firdes.low_pass(1.0, 
        band_rate*param.num_bands, 
        0.4*band_rate , 
        0.1*band_rate ,
        gr.firdes.WIN_HANN)
    print "Band filter has", len(taps), "taps"

    # note that playing with number of taps didn't improve the situation. 
    # Replace the line '0.1*band_rate" with '0.4', '0.6', '1.0', '2.0', etc. 
    
    self.v = [ blks2.analysis_filterbank(nbank,taps) for j in range(nchan) ]  # nbank transmitters !! 
    #self.v = [ gr.fir_filter_ccf(nbank,taps) for j in range(nchan) ]         # this works for one transmitter !!
    #self.v = [ gr.deinterleave(gr.sizeof_gr_complex) for j in range(nchan) ] # this does nothing
    for j in range(nchan):
      self.u.set_center_freq(fpga_frequency,j)
      self.connect((self.u,j), self.v[j])

    # We determined experimentally that this point in the processing graph 
    # created the bottlneck which caused the USRP to overflow. This is a result
    # of the sheer number of mathematical operations performed by the block. We 
    # are exploring a few different solutions: 
    #  
    #  (1) add a gr.keep_one_in_n filter before blks2.analysis_filterbank
    #      in order to reduce the load on the filter bank. This is "ok" as 
    #      long as the sample rate is wider than the smallest transmitter 
    #      pulse width. THIS WON'T WORK. filter, then decimate, otherwise 
    #      the world explodes. 'cause of Nyquist Thm -Todd 
    #
    #  (2) use an alternative filtering algorithm which requires less 
    #      processing power, for example a fir_filter. THIS ONLY ALLOWS ONE 
    #      TRANSMITTER. 
    # 
    #  (3) find an alternative system. The Soekris net6501 uses an intel Atom
    #      which (w/o evidence) is inadequate for the processing required by 
    #      this filter. Two alternatives to test would be a faster processeor 
    #      (1.0 Ghz Atom to 1.6 Ghz Atom) and a dual-core system. 
    #
    # Chris Patton 07 Aug 2012
    
    print "creating detector bank"    
    filter_length = 160
    self.w = []
    for i in range(nbank): # range(1) for one transmitter
      det = detect(filter_length,filter_length*3,nchan,str('./dtest' + str(i) + '_'), band_rate, 0, USE_PSD)
      #det.rise_factor(3)
      #det.fall_factor(2)
      #det.alpha_factor(0.01)
      self.w.append(det)

      for j in range(nchan):
        self.connect((self.v[j],i),(self.w[i],j))

    print "enabling detectors"    
    for j in param.tunings[0].bands:
      if (j.tx_type == rmg_param.PULSE):
        #filter_length = int(round(j.pw*param.bw/1000))
        self.w[j.band_num].rise_factor(j.rise)
        self.w[j.band_num].fall_factor(j.fall)
        self.w[j.band_num].alpha_factor(j.alpha)
        print (j.filter_length, j.filter_length*3, j.file_prefix, j.cf, USE_PSD)
        self.w[j.band_num].enable(filter_length,filter_length*3, str(j.file_prefix), j.cf, USE_PSD)

      elif (j.tx_type == rmg_param.CONT):
        self.w[j.band_num].enable_cont(str(j.file_prefix + time.strftime('%Y%m%d%H%M%S') + '.tdat'))
    
    
  def __load_param(self, filename):
  #
  # Load a CSV formatted list of transmitters and calculate 
  # the USRP tuning parameters.  Chris ~18 Sep 2012
  #
    parameters = rmg_param.parameters(filename)
    self.high_lo =       parameters.high_lo
    self.decim =         parameters.decim
    self.backend_param = parameters.be_params

    self.num_be = self.backend_param.num_tunings
    if self.sc != None:
      if self.high_lo:
        self.sc.use_high_lo()
      else:
          self.sc.use_low_lo()





if __name__ == '__main__':
  det = None

  try: 
    det = Detector()
    det.start()
    raw_input()
    
  except KeyboardInterrupt: 
    pass
    
  finally:  
    if det: det.stop()
  
      
                              

    















#parser = OptionParser ()
#parser.add_option ("-f", "--dfc_file", type="string", 
#	                   default="default.dfc", 
#			   help="dfc file name")
#parser.add_option ("-t", "--time", type="int",
#                           default=6,
#                           help="time in seconds to look at each frequency")
#parser.add_option ("-p", "--port", type="string",
#                           default="/dev/ttyS0",
#                           help="serial port for communication to RMG PIC")
#(options, args) = parser.parse_args()
#
#if len(args) != 0:
#    parser.print_help()
#    raise SystemExit
#
#dir_finder = rmg.rmg_run.detector_array(options.dfc_file, options.port)
#dir_finder.run(options.time)

#dir_finder.start()
#time.sleep(10)
#dir_finder.stop()
#dir_finder.next()

#!/usr/bin/python
# rmg_position
# Calculate the position of a target transmitter over a given
# time range. The function position_estimation() represents 
# our first iteration of this algorithm. This program 
# is part of QRAAT, an utomated animal tracking system 
# based on GNU Radio. 
#
# Copyright (C) 2013 Todd Borrowman, Christopher Patton
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import MySQLdb as mdb
import numpy as np
import time, os, sys
import qraat.csv


# Get database credentials. 
def get_db_cursor():
  try: 
    db_config = qraat.csv("%s/db_auth" % os.environ['RMG_SERVER_DIR']).get(view='writer')

  except KeyError: 
    print >>sys.stderr, "position: error: undefined environment variables. Try `source rmg_env.`" 
    sys.exit(1) 

  except IOError, e: 
    print >>sys.stderr, "position: error: missing DB credential file '%s'." % e.filename
    sys.exit(1)

  # Connect to the database. 
  db_con = mdb.connect(db_config.host, 
                       db_config.user,
                       db_config.password,
                       db_config.name)
  return db_con.cursor()

def get_site_data(cur, cal_id):
  print "position: fetching site and cal data"

  # Get site locations.
  sites = qraat.csv(db_con=db_con, db_table='sitelist')

  # Get steering vector data.
  steering_vectors = {} # site.ID -> sv
  bearings = {}         # site.ID -> bearing
  to_be_removed = []
  for site in sites:
    cur.execute('''SELECT Bearing, 
                          sv1r, sv1i, sv2r, sv2i, 
                          sv3r, sv3i, sv4r, sv4i 
                     FROM Steering_Vectors 
                    WHERE SiteID=%d and Cal_InfoID=%d''' % (site.ID, cal_id))
    sv_data = np.array(cur.fetchall(),dtype=float)
    if sv_data.shape[0] > 0:
      steering_vectors[site.ID] = np.array(sv_data[:,1::2] + np.complex(0,1) * sv_data[:,2::2])
      bearings[site.ID] = np.array(sv_data[:,0])
    else:
      to_be_removed.append(site)
  while len(to_be_removed) > 0:
    sites.table.remove(to_be_removed.pop())

  # Format site locations as np.complex's. 
  for site in sites:
    setattr(site, 'pos', np.complex(sites[j].northing, sites[j].easting))

  return (sites, bearings, steering_vectors)

def get_est_data(cur, t_start, t_end, tx_id):
  print "position: fetching pulses for transmitter and time range"

  # Get pulses in time range.  
  cur.execute('''SELECT ID, siteid, timestamp,
                        ed1r, ed1i, ed2r, ed2i,
                        ed3r, ed3i, ed4r, ed4i
                   FROM est
                  WHERE timestamp >= %s
                    AND timestamp <= %s
                    AND txid = %s
                  ORDER BY timestamp ASC''', (t_start, 
                                              t_end, 
                                              tx_id))

  signal_data = np.array(cur.fetchall(), dtype=float)
  est_ct = signal_data.shape[0]
  if est_ct == 0:
    print >>sys.stderr, "position: fatal: no est records for selected time range."
    sys.exit(1)
  else: print "position: processing %d records" % est_ct

  sig_id =   np.array(signal_data[:,0], dtype=int)
  site_id =  np.array(signal_data[:,1], dtype=int)
  est_time = signal_data[:,2]
  signal =   signal_data[:,3::2]+np.complex(0,-1)*signal_data[:,4::2]
  return (sig_id, site_id, est_time, signal)

# Calculate the likelihood of each bearing for each pulse. 
def calc_likelihoods(signal, site_id, bearings, steering_vectors):
  print "position: calculating pulse bearing likelihoods"

  likelihoods = np.zeros((est_ct,360))
  for i in range(signal.shape[0]):
    try: 
      sv =  steering_vectors[site_id[i]]
    except KeyError:
      print >>sys.stderr, "position: error: no steering vectors for site ID=%d" % site_id[i]
      sys.exit(1)

    sig = signal[i,np.newaxis,:]
    left_half = np.dot(sig, np.conj(np.transpose(sv)))
    bearing_likelihood = (left_half * np.conj(left_half)).real
    for j, value in enumerate(bearings[site_id[i]]):
      likelihoods[i, value] = bearing_likelihood[0, j]
  return likelihoods



def position_estimation(i, j, center, scale, half_span=15):
  ''' Estimate the position of a transmitter over time interval ``[i, j]``.

    Generate a set of candidate points centered around ``center``. 
    Calculate the bearing to the receiver sites from each of this points. 
    The log likelihood of a candidate corresponding to the actual location
    of the target transmitter over the time window is equal to the sum of
    the likelihoods of each of these bearings given the signal characteristics
    of the ESTs in the window. 
  '''
  
  #: Generate candidate points centered around ``center``. 
  grid = np.zeros((half_span*2+1, half_span*2+1),np.complex)
  for e in range(-half_span,half_span+1):
    for n in range(-half_span,half_span+1):
      grid[e + half_span, n + half_span] = center + np.complex(n * scale, e * scale)

  #: The third dimension of the search space: bearings from each 
  #: candidate point to each receiver site. 
  #site_bearings = np.zeros(np.hstack((grid.shape,len(sites))))
  site_bearings = {}
  for site in sites:
    #site_bearings[:,:,sv_index] = np.angle(grid - site.pos) * 180 / np.pi
    site_bearings[site.id] = np.angle(grid - site.pos) * 180 / np.pi

  #: Based on bearing likelihoods for EST's in time range, calculate
  #: the log likelihood of each candidate point. 
  pos_likelihood = np.zeros(site_bearings.shape[0:2])
  for est_index in range(i, j): 
    sv_index = site_id[est_index]
    try:
      pos_likelihood += np.interp(site_bearings[sv_index], 
                                range(-360, 360), 
                                np.hstack((likelihoods[est_index,:], 
                                likelihoods[est_index,:])) )
    except KeyError:
      pass

  return grid.flat[np.argmax(pos_likelihood)]

def calc_positions(cal_id, tx_id, t_start, t_end, t_delta, t_window, verbose = False, cur = None):
  if cur is None:
    cur = get_db_cursor()
  (sites, bearings, steering_vectors) = get_site_data(cur, cal_id)
  (sig_id, site_id, est_time, signal) = get_est_data(cur, t_start, t_end, tx_id)
  likelihoods = calc_likelihoods(signal, site_id, bearings, steering_vectors)



  #: Calculated positions (time, pos). 
  pos_est = [] 

  #: The time step (in seconds) for the position estimation
  #: calculation.
  #t_delta = options.t_delta

  #: Time averaging window (in seconds). 
  #t_window = options.t_window

  #: Center of Quail Ridge reserve (northing, easting). This is the first
  #: "candidate point" used to construct the search space grid. 
  center = np.complex(4260500, 574500) 

  print "position: calculating position"
  if verbose:
    print "%15s %-19s %-19s %-19s" % ('time window', 
                '100 meters', '10 meters', '1 meter')

  i = 0

  try: 
    while i < est_ct - 1:

      # Find the index j corresponding to the end of the time window. 
      j = i + 1
      while j < est_ct - 1 and (est_time[j + 1] - est_time[i]) <= t_window: 
        j += 1

      if verbose: 
        print "%7d %7d" % (i, j), 
      
      scale = 100
      pos = center
      while scale >= 1: # 100, 10, 1 meters ...  
        pos = position_estimation(i, j, pos, scale)
        if verbose:
          print "%8dn,%de" % (pos.real, pos.imag),
        scale /= 10
      pos_est.append((tx_id, 
                      est_time[(i + j) / 2], 
                      pos.imag,  # easting 
                      pos.real)) # northing

      if verbose: print

      # Step index i forward t_delta seconds. 
      j = i + 1
      while i < est_ct - 1 and (est_time[i + 1] - est_time[j]) <= t_delta: 
        i += 1

  except KeyboardInterrupt: pass

  finally:

    # Insert results into database. 
    cur.executemany('''INSERT INTO Position 
                        (txid, timestamp, easting, northing)
                       VALUES (%s, %s, %s, %s)''', pos_est)
    return (pos_est, sites)

if __name__ == "__main__":
  from optparse import OptionParser

  parser = OptionParser()

  parser.description = '''\
  Calculate the position of a target transmitter of a specified time 
  range. Times are given as seconds as floating points. For example,
  to calculate the position of transmitter ID=12 from 1:30PM on
  June 14, 1999 to now, do "rmg_position --tx-id=12 
  --t-start=$(date --date='19990614 1330' +%s) --t-end=$(date +%s) 
  --plot". This program is part of QRAAT, an automated animal tracking 
  system based on GNU Radio.   
  '''

  parser.add_option('--cal-id', type='int', metavar='INT', default=1,
                    help="Calibration ID, the serial identifier in the database "
                         "context identifying a calibration run. (Default is 1.)")

  parser.add_option('--tx-id', type='int', metavar='INT', default=51,
                    help="Serial ID of the target transmitter in the database "
                         "context.")

  parser.add_option('--t-delta', type='float', metavar='SEC', default=1.0,
                    help="Time step for each position calculation. (Default "
                         "is 1.0 seconds.) ")

  parser.add_option('--t-window', type='float', metavar='SEC', default=30.0,
                    help="Time window to use for the position likelihood "
                         "calculation at each time step. (Default is 30.0 "
                         "seconds.)")

  parser.add_option('--t-start', type='float', metavar='SEC', default=1376420800.0, 
                    help="Start time in secondes after the epoch (UNIX time).")

  parser.add_option('--t-end', type='float', metavar='SEC', default=1376442000.0, 
                    help="End time in secondes after the epoch (UNIX time).")

  parser.add_option('--plot', action='store_true', default=False, 
                    help="Show positions and receiver sites.")

  parser.add_option('-v', '--verbose', action='store_true', default=False, 
                    help="Print the progression of the algorithm to the terminal.")

  (options, args) = parser.parse_args()

  #TODO source rmg_env

  (pos_est, sites) = calc_positions(options.cal_id, options.tx_id, options.t_start, options.t_end, options.t_delta, options.t_window, options.verbose)  

  if options.plot: 

    import matplotlib.pyplot as pp

    # Plot sites.
    pp.plot(
     [s.easting for s in sites], 
     [s.northing for s in sites], 'ro')

    # Plot locations. 
    pp.plot( 
     map(lambda (tx, t, e, n): e, pos_est), 
     map(lambda (tx, t, e, n): n, pos_est), '.', alpha=0.3)

    pp.show()



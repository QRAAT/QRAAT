#!/usr/bin/python

import matplotlib.pyplot as pp
import MySQLdb as mdb
import numpy as np
import time, os, sys
import qraat
from optparse import OptionParser

parser = OptionParser()

parser.description = '''\
Calculate the position of a target transmitter of a specified time 
range. This program is part of QRAAT, an automated animal tracking 
system based on GNU Radio.   
'''

parser.add_option('--cal-id', type='int', metavar='INT', default=1,
                  help="Calibration ID, the serial identifier in the database "
                       "context identifying a calibration run. (Default is 1.)")

parser.add_option('--tx-id', type='int', metavar='INT', default=0,
                  help="Serial ID of the target transmitter in the database "
                       "context.")

parser.add_option('--t-delta', type='float', metavar='SEC', default=1.0,
                  help="Time step for each position calculation. (Default "
                       "is 1.0 seconds.) ")

parser.add_option('--t-window', type='float', metavar='SEC', default=30.0,
                  help="Time window to use for the position likelihood "
                       "calculation at each time step. (Default is 30.0 "
                       "seconds.)")

parser.add_option('--t-start', type='float', metavar='SEC', default=1376420800.0, 
                  help="Start time in secondes after the epoch (UNIX time).")

parser.add_option('--t-end', type='float', metavar='SEC', default=1376442000.0, 
                  help="End time in secondes after the epoch (UNIX time).")

parser.add_option('--plot', action='store_true', default=False, 
                  help="Show positions and receiver sites.")

parser.add_option('-v', '--verbose', action='store_true', default=False, 
                  help="Print the progression of the algorithm to the terminal.")

(options, args) = parser.parse_args()

# Get database credentials. 
try: 
  db_config = qraat.csv("%s/db_auth" % os.environ['RMG_SERVER_DIR']).get(view='reader')

except KeyError: 
  print >>sys.stderr, "position: error: undefined environment variables. Try `source rmg_env.`" 
  sys.exit(1) 

except IOError, e: 
  print >>sys.stderr, "position: error: missing DB credential file '%s'." % e.filename
  sys.exit(1)

# Connect to the database. 
db_con = mdb.connect(db_config.host, 
                     db_config.user,
                     db_config.password,
                     db_config.name)
cur = db_con.cursor()

print "position: fetching site and cal data"

# Get site locations.
sites = qraat.csv(db_con=db_con, db_table='sitelist')

# Get steering vector data.
steering_vectors = {} # site.ID -> sv
bearings = {}         # site.ID -> bearing

for site in sites:
  cur.execute('''SELECT Bearing, 
                        sv1r, sv1i, sv2r, sv2i, 
                        sv3r, sv3i, sv4r, sv4i 
                   FROM Steering_Vectors 
                  WHERE SiteID=%d and Cal_InfoID=%d''' % (site.ID, options.cal_id))
  sv_data = np.array(cur.fetchall(),dtype=float)
  if sv_data.shape[0] > 0:
    steering_vectors[site.ID] = np.array(sv_data[:,1::2] + np.complex(0,1) * sv_data[:,2::2])
    bearings[site.ID] = np.array(sv_data[:,0])

print "position: fetching pulses for transmitter and time range"

# Get pulses in time range.  
cur.execute('''SELECT ID, siteid, timestamp,
                      ed1r, ed1i, ed2r, ed2i,
                      ed3r, ed3i, ed4r, ed4i
                 FROM est
                WHERE timestamp >= %s
                  AND timestamp <= %s
                  AND txid = %s
                ORDER BY timestamp ASC''', (options.t_start, 
                                            options.t_end, 
                                            options.tx_id))

signal_data = np.array(cur.fetchall(), dtype=float)
est_ct = signal_data.shape[0]
if est_ct == 0:
  print >>sys.stderr, "position: fatal: no est records for selected time range."
  sys.exit(1)
else: print "position: processing %d records" % est_ct

sig_id =   np.array(signal_data[:,0], dtype=int)
site_id =  np.array(signal_data[:,1], dtype=int)
est_time = signal_data[:,2]
signal =   signal_data[:,3::2]+np.complex(0,-1)*signal_data[:,4::2]

print "position: calculating pulse bearing likelihoods"

# Calculate the likelihood of each bearing for each pulse. 
likelihoods = np.zeros((est_ct,360))
for i in range(est_ct):
  # TODO error: no steering vectors for site_id
  sv =  steering_vectors[site_id[i]]
  sig = signal[i,np.newaxis,:]
  left_half = np.dot(sig, np.conj(np.transpose(sv)))
  bearing_likelihood = (left_half * np.conj(left_half)).real
  for j, value in enumerate(bearings[site_id[i]]):
    likelihoods[i, value] = bearing_likelihood[0, j]

# Format site locations as np.complex's. 
site_pos = np.zeros((len(sites),),np.complex)
site_pos_id = []
for j in range(len(sites)):
  site_pos[j] = np.complex(sites[j].northing, sites[j].easting)
  site_pos_id.append(sites[j].ID)

def position_estimation(i, j, center, scale, half_span=15):
  ''' Estimate the position of a transmitter over time interval ``[i, j]``. 

    (i, j) - interval over EST data 
    center - Center point for generating a grid of candidate points
    returns estimated point
  '''
  
  #: Generate candidate points centered around ``center``. 
  grid = np.zeros((half_span*2+1, half_span*2+1),np.complex)
  for e in range(-half_span,half_span+1):
    for n in range(-half_span,half_span+1):
      grid[e + half_span, n + half_span] = center + np.complex(n * scale, e * scale)

  #: The third dimension of the search space: bearings from each 
  #: candidate point to each receiver site. 
  site_bearings = np.zeros(np.hstack((grid.shape,len(site_pos_id))))
  for sv_index, id_index in enumerate(site_pos_id):
    site_bearings[:,:,sv_index] = np.angle(
      grid - site_pos[site_pos_id.index(id_index)]) * 180 / np.pi

  #: Based on bearing likelihoods for EST's in time range, calculate
  #: the log likelihood of each candidate point. 
  pos_likelihood = np.zeros(site_bearings.shape[0:2])
  for est_index in range(i, j): 
    sv_index = site_pos_id.index(site_id[est_index])
    pos_likelihood += np.interp(site_bearings[:,:,sv_index], 
                                range(-360, 360), 
                                np.hstack((likelihoods[est_index,:], 
                                likelihoods[est_index,:])) )

  return grid.flat[np.argmax(pos_likelihood)]


#: Calculated positions (time, pos). 
pos_est = [] 

#: The time step (in seconds) for the position estimation
#: calculation.
t_delta = options.t_delta

#: Time averaging window (in seconds). 
t_window = options.t_window

#: Center of Quail Ridge reserve (northing, easting). This is the first
#: "candidate point" used to construct the search space grid. 
center = np.complex(4260500, 574500) 

print "position: calculating position"
if options.verbose:
  print "%15s %-19s %-19s %-19s" % ('time window', 
              '100 meters', '10 meters', '1 meter')

i = 0

try: 
  while i < est_ct - 1:

    # Find the index j corresponding to the end of the time window. 
    j = i + 1
    while j < est_ct - 1 and (est_time[j + 1] - est_time[i]) <= t_window: 
      j += 1

    if options.verbose: 
      print "%7d %7d" % (i, j), 
    
    scale = 100
    pos = center
    while scale >= 1: # 100, 10, 1 meters ...  
      pos = position_estimation(i, j, pos, scale)
      if options.verbose:
        print "%8dn,%de" % (pos.real, pos.imag),
      scale /= 10
    pos_est.append((est_time[(i + j) / 2], pos))

    if options.verbose: print

    # Step index i forward t_delta seconds. 
    j = i + 1
    while i < est_ct - 1 and (est_time[i + 1] - est_time[j]) <= t_delta: 
      i += 1

except KeyboardInterrupt: pass

finally:

  if options.plot: 
    # Plot sites.
    pp.plot(
     [s.easting for s in sites], 
     [s.northing for s in sites], 'ro')

    # Plot locations. 
    pp.plot( 
     map(lambda (t,x): x.imag, pos_est), 
     map(lambda (t,x): x.real, pos_est), '.', alpha=0.3)

    pp.show()

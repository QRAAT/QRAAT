#!/bin/bash
# rmg
# This script is part of the QRAAT system. It provides basic server
# side controls for RMG comptures/receiver running remotely. 
#
# Copyright (C) 2013 Christopher Patton
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Notes
# 
# Meta data (transmitter file, log files, etc.) is stored persistently on
# disk on the RMG remotes, typically in /home/rmg. Data (.det files, 
# status.txt) is written in memory to ramdisk, typically /tmp/ramdisk/det.
# 
# We make heavy use of SSH. To avoid entering passwords all the time, we 
# use an RSA encryption key with no passphrase. The public key is stored 
# at all RMG remote sites in /home/rmg/.ssh/authorized_keys; the private 
# key is kept at the server, typically /home/rmg/.ssh/rmg_rsa. This is 
#because the remotes run the SSH daemon. 
#
# Tasks 
# 
#  'up/down'
# 
# Power the physical hardware on and off. The relevant components are the 
# RMG receiver and the host computer, called the "RMG remote". The power
# supply for these will run through a network addressible hub. Theoretically,
# we should be able to tell this device to turn it sattached components on 
# and off. 
#     'up' does nothing special, but 'down' will SIGINT the run_rmg program 
# if it's running. Next, it sends the RMG remote the halt signal, waits a 
# sufficient amount of time (say 5 seconds), and powers the computer off. 
#     A list of up sites is stored in $(pwd)/up_sites. 
#
#  'start/stop'
# 
# Run and kill the pulse detector module (run_rmg). Output is logged in a 
# file in the meta data directory.
#
#  'fetch' 
#
# Download pulse data (.det files) from RMG remote to RMG server. Upon 
# success, erase the transfered data from the RMG remote. The pulse detector 
# in the RMG module emits .det files into a directory structure like 
# YYYY/MM/DD/HH/mm/ssuuuuuu.det. We want to be able to copy these files from 
# RMG remotes to the server, but exclude the directory that is being mutated. 
#       One solution would be to implement a hot-directory locking 
# mechanism on the RMG remote side. Since we don't want to burden the site 
# computers with this extra work, we decided to take advantage of the fact 
# that the real clock time must be synchronized across all nodes of the 
# network. We fetch all directories that are older than one minute because 
# the pulse detector will never mutate these directories again. 
#
#  'updatetx' 
#
# Update transmitter information on specified sites. This task includes an
# option to specify a file. 
#
#  'cyclerx'
#
# Cycle the power on the RMG module.  
#
# TODOs 
# 
# - 'cyclerx', 'up', 'down'.
# We now have one network addressible power supply. We will have a file that
# stores all configuration data for all sites, as well as status bits. For 
# each site, we'll have a record like (name, comp_ip, power_ip, comp_outlet
# int, rx_outlet int, powertype, status {"down", "up", "active"}). When this 
# script starts, it will read the file. When it finishes, it will write it 
# again. An external script will do Power (powertype, power_ip, action {"ON", 
# "OFF", "CYCLE"}). Each powertype has its own means of interacting with the 
# network. For example, for the one Marcel and I worked on, 
# curl --user admin:1234 "http://192.168.0.100/outlet?1=OFF" 
# is sufficient. 
# - Run task on 'all' sites. 
#

. rmg_env  # setup RMG environment variables

HOST_METADATA_DIR=$RMG_SITE_METADATA_DIR      # Transmitter configuration file
HOST_DATA_DIR=$RMG_SITE_DET_DIR   # Where .det files are stored
KEY=$RMG_SERVER_SSH_KEYFILE           # location of RSA encryption key
SERVER_DET_DIR=$RMG_SERVER_DET_DIR #location to put det files on server
SITELIST_FILE=$RMG_SERVER_SITELIST #list of remote sites

function help() {
  cat <<!EOF!
usage: rmg task [-options] {sites}/all  

  This program is part of the QRAAT system. It provides basic controls
  for RMG computers/receivers running in the field. Perform a batch job
  on a list of sites. If 'all' is provided, the job will be dispatched to 
  all up sites.   

  'task' is any one of the following: 

    up           Power on remote computer and RMG receiver. If no arguments
                 provided, print sites currently up. 

    down         Power off remote computer and RMG receiver. 

    start        Sart RMG software defined radio. Store pulse data remotely. 

    stop         Stop running RMG software defined radio. 

    fetch        Download pulse data from site to server. Delete downloaded 
                 data from remote machine. 
    
    updatetx --file FILE    Update transmitter file on remote computer. 
                            Defaults to 'tx.csv' in working directory.

    cyclerx      Power off the RMG receiver and power it back on.

    help         Print this. 
!EOF!
}

function fetch() {
# Input a list of directories on remote host. Output directories containing 
# .det's to be copied, excluding those younger than one minute. 
  python -c 'import os, re, time, sys
class Tree: 

  def __init__(self, parent=None, hot=False):
    self.hot = hot
    self.parent = parent
    self.children = {}
  
  def insert(self, branch, hot): 
  # insert a branch
    if not self.hot and hot:  # if hot once, hot forever
      self.hot = hot
    if branch == []:
      return
    else:
      try:  
        self.children[branch[0]].insert(branch[1:], hot)
      except KeyError: 
        self.children[branch[0]] = Tree(self)
        self.children[branch[0]].insert(branch[1:], hot)        

  def copiable(self, directory=None): 
  # emit non-hot, i.e. copiable,  directories.
    if self.parent == None: # root directory
      (name, child) = (self.children.keys()[0], self.children.values()[0])
      child.copiable(directory + "/" + name)
    elif self.hot == False: # no children hot, this whole directory can be copied
      print directory
    else:                   # directory has a hot child, recurse
      for (name, child) in self.children.iteritems():
        child.copiable(directory + "/" + name)


prog = re.compile("([0-9]{4})(\/([0-9]{2})){4}") 

now = time.localtime(time.time() - (120)) # Exclude last two minutes, actually. This 
                                          # is to account for possible synchronization 
                                          # issues-up to one minute of clock slippage. 
                                        
t = [now.tm_year, now.tm_mon, now.tm_mday, now.tm_hour, now.tm_min]

tree = Tree()

for line in sys.stdin.readlines():
  if prog.search(line): 
    
    # Fetch if directory is sufficiently old. 
    d = line.strip().split("/")
    ts = map(lambda n: int(n), d[1:])
    fetch = True
    for i in range(len(ts)):
      if ts[i] < t[i]: break
      elif ts[i] > t[i]: 
        fetch = False
        break 

    tree.insert(d[1:], hot=not fetch)

try: 
  tree.copiable(d[0])
except: pass'
}


## Get task and options ##
TASK=$1 
shift

case $TASK in
 -h|--help|help)
   help
   exit 0
  ;; 

  updatetx)
    if [[ "$1" == "-f" ]] || [[ "$1" == "--file" ]] 
    then
      TX_FILE=$2
      shift
      shift
    else     
      TX_FILE="tx.csv"
    fi
  ;;
esac 


## List of sites to run routine on ##
SITES=""
for SITE in $@ 
do
  if [[ $SITE =~ [0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3} ]] || [[ $(grep /etc/hosts -e "$SITE") ]] 
  then
    [[ ! $SITES =~ $SITE ]] && SITES="$SITES $SITE"
  else
    echo error: site \'$SITE\` not recognized.
    exit 1
  fi
done


## List of sites that are currently up ##
UP_SITES=$(cat up_sites 2> /dev/null)


## Run tasks at each site ##
count=0
for SITE in $SITES
do
  case $TASK in 
    up)
      if [[ $UP_SITES =~ $SITE ]]
      then
        echo "$SITE already up!"
      else
        echo "up $SITE"
        UP_SITES="$UP_SITES $SITE"
        # TODO power up RMG receiver and computer
      fi
    ;; 

    down)
      if [[ $UP_SITES =~ $SITE ]]
      then
        echo "down $SITE"
        UP_SITES=`echo ${UP_SITES[@]//$SITE/}`
        ssh -i $KEY rmg@$SITE "/usr/bin/killall run_rmg 2> /dev/null \
                               /sbin/halt"
        sleep 5 
        # TODO power down RMG receiver and computer
      else 
        echo "$SITE already down!"
      fi
    ;;
    
    start) 
      echo "start $SITE"
      # Start an RMG process on remote machine. Redirect all output to a 
      # timestamped log file. 
      if [[ $UP_SITES =~ $SITE ]]
      then
        ssh -i $KEY rmg@$SITE "/usr/local/bin/run_rmg -d $HOST_DATA_DIR -f $HOST_METADATA_DIR/tx.csv &> \
                               $HOST_METADATA_DIR/run_rmg_$(date -d 'today' +'%Y.%m.%d_%H.%M').txt &"
      else 
        echo "$SITE is currently down."
      fi 
    ;;

    stop) 
      echo "stop $SITE"
      if [[ $UP_SITES =~ $SITE ]]
      then
        ssh -i $KEY rmg@$SITE '/usr/bin/killall run_rmg 2> /dev/null'
      else 
        echo "$SITE is currently down."
      fi 
    ;;

    fetch)
      echo "fetch $SITE"
      DIRECTORIES_TO_COPY=$(ssh -i $KEY rmg@$SITE "cd $HOST_DATA_DIR && find -type d" | fetch) # directories to copy
      mkdir -p $SERVER_DET_DIR/$SITE 
      ct=0
      for DIR in $DIRECTORIES_TO_COPY; do
        echo "copying $DIR"
        mkdir -p $SERVER_DET_DIR/$SITE/$DIR
        rsync -ave "ssh -i $KEY" rmg@$SITE:$HOST_DATA_DIR/$DIR/* $SERVER_DET_DIR/$SITE/$DIR # download to RMG server
        ssh -i $KEY rmg@$SITE "rm -r $HOST_DATA_DIR/$DIR"                   # delete from RMG remote
        let ct=ct+1
      done
      if [ $ct -eq 0 ]; then echo "Nothing to fetch."; fi
    ;;
    
    updatetx) 
      echo "udpatetx $SITE"
      if [ -e $TX_FILE ]
      then
        scp -i $KEY $TX_FILE rmg@$SITE:$HOST_METADATA_DIR/tx.csv 
      else 
        echo "error: '$TX_FILE' doesn't exist"
      fi
    ;;

    cyclerx)
      echo "cyclerx $SITE" 
      # TODO Cycle RMG receiver power. 
    ;;
    
    *)
      echo error: unrecognized task \'$TASK\'
      exit 1
    ;;

  esac
  let count=count+1
done


if [ $count -eq 0 ]
then
  case $TASK in
  up) # if no sites provided by user, just list up sites
    echo up $UP_SITES
    ;;
    
  esac
fi 

echo $UP_SITES | cat > up_sites
export UP_SITES

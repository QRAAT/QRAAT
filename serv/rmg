#!/bin/bash
# rmg
# This script is part of the QRAAT system. It provides basic server
# side controls for RMG comptures/receiver running remotely. 
#
# Copyright (C) 2013 Christopher Patton
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Notes
# 
# Meta data (transmitter file, log files, etc.) is stored persistently on
# disk on the RMG remotes, typically in /home/rmg. Data (.det files, 
# status.txt) is written in memory to ramdisk, typically /tmp/ramdisk/det.
# 
# We make heavy use of SSH. To avoid entering passwords all the time, we 
# use an RSA encryption key with no passphrase. The public key is stored 
# at all RMG remote sites in /home/rmg/.ssh/authorized_keys; the private 
# key is kept at the server, typically /home/rmg/.ssh/rmg_rsa. This is 
#because the remotes run the SSH daemon. 
#
# Tasks 
# 
#  'up/down'
# 
# Power the physical hardware on and off. The relevant components are the 
# RMG receiver and the host computer, called the "RMG remote". The power
# supply for these will run through a network addressible hub. Theoretically,
# we should be able to tell this device to turn it sattached components on 
# and off. 
#     'up' does nothing special, but 'down' will SIGINT the run_rmg program 
# if it's running. Next, it sends the RMG remote the halt signal, waits a 
# sufficient amount of time (say 5 seconds), and powers the computer off. 
#     A list of up sites is stored in $(pwd)/up_sites. 
#
#  'start/stop'
# 
# Run and kill the pulse detector module (run_rmg). Output is logged in a 
# file in the meta data directory.
#
#  'fetch' 
#
# Download pulse data (.det files) from RMG remote to RMG server. Upon 
# success, erase the transfered data from the RMG remote. The pulse detector 
# in the RMG module emits .det files into a directory structure like 
# YYYY/MM/DD/HH/mm/ssuuuuuu.det. We want to be able to copy these files from 
# RMG remotes to the server, but exclude the directory that is being mutated. 
#       One solution would be to implement a hot-directory locking 
# mechanism on the RMG remote side. Since we don't want to burden the site 
# computers with this extra work, we decided to take advantage of the fact 
# that the real clock time must be synchronized across all nodes of the 
# network. We fetch all directories that are older than one minute because 
# the pulse detector will never mutate these directories again. 
#
#  'updatetx' 
#
# Update transmitter information on specified sites. This task includes an
# option to specify a file. 
#
#  'cyclerx'
#
# Cycle the power on the RMG module.  
#
# TODOs 
# 
# - 'cyclerx', 'up', 'down'.
# - Try to read/write sitelist.csv just once. 
# - Run task on 'all' sites. 
#
#

. rmg_env  # setup RMG environment variables

function help() {
  cat <<!EOF!
usage: rmg task [-options] {sites}/all  

  This program is part of the QRAAT system. It provides basic controls
  for RMG computers/receivers running in the field. Perform a batch job
  on a list of sites. If 'all' is provided, the job will be dispatched to 
  all up sites.   

  'task' is any one of the following:

    status       Show status of a site (active/up/down). 

    up           Power on remote computer and RMG receiver. If no arguments
                 provided, print sites currently up. 

    down         Power off remote computer and RMG receiver. 

    start        Sart RMG software defined radio. Store pulse data remotely. 

    stop         Stop running RMG software defined radio. 

    fetch        Download pulse data from site to server. Delete downloaded 
                 data from remote machine. 
    
    updatetx --file FILE    Update transmitter file on remote computer. 
                            Defaults to 'tx.csv' in working directory.

    cyclerx      Power off the RMG receiver and power it back on.

    help         Print this. 
!EOF!
}


## Configuration and status of sites ##
touch $RMG_SERVER_SITELIST 2> /dev/null
if [ $? -ne 0 ]; 
then
  echo "error: site configuration information not available (no sitelist.csv)."
  exit 1
fi 

function update_sitelist () {
  SITE=$1
  ENTRY=$2
  VALUE=$3
  rmg_sitelist.py $SITE $ENTRY $VALUE < $RMG_SERVER_SITELIST > tmp.csv
  mv tmp.csv $RMG_SERVER_SITELIST
}

function get_sitelist() {
  SITE=$1
  ENTRY=$2
  rmg_sitelist.py $SITE $ENTRY < $RMG_SERVER_SITELIST
}


## Get task and options ##
TASK=$1 
shift

if [ ! $TASK ]
then
  help
  exit 0
fi

case $TASK in
 -h|--help|help)
   help
   exit 0
  ;; 

  updatetx)
    if [[ "$1" == "-f" ]] || [[ "$1" == "--file" ]] 
    then
      TX_FILE=$2
      shift
      shift
    else     
      TX_FILE="tx.csv"
    fi
  ;;

  status|up|down|start|stop|fetch|cyclerx)
  ;; 
    
  *)
    echo error: unrecognized task \'$TASK\'
    exit 1
  ;;

esac 


## Site list ##
SITES=$@


## Run tasks at each site ##
count=0
for SITE in $SITES
do

  STATUS=$(get_sitelist $SITE status)
  if [ $? -ne 0 ]; then 
    echo error: site \'$SITE\' not recognized. 
    exit 1
  fi 

  case $TASK in 
    status)
      echo "$SITE is $STATUS"
    ;;

    up)
      if [[ $STATUS == "up" ]] || [[ $STATUS == "active" ]]
      then
        echo "$SITE already up!"
      else
        echo "up $SITE"
        # TODO
        update_sitelist $SITE status up
      fi
    ;; 

    down)
      if [[ $STATUS == "up" ]] || [[ $STATUS == "active" ]]
      then
        echo "down $SITE"
        ssh -i $RMG_SERVER_SSH_KEYFILE rmg@$SITE "/usr/bin/killall run_rmg 2> /dev/null && /sbin/halt"
        sleep 5 # wait an appropriate time 
        # TODO 
        update_sitelist $SITE status down
      else 
        echo "$SITE already down!"
      fi
    ;;
    
    start) 
      echo "start $SITE"
      # Start an RMG process on remote machine. Redirect all output to a 
      # timestamped log file. 
      if [[ $STATUS == "up" ]]
      then
        ssh -i $RMG_SERVER_SSH_KEYFILE rmg@$SITE \
            "/usr/local/bin/run_rmg -d $RMG_SITE_DET_DIR -f $RMG_SITE_METADATA_DIR/tx.csv &> \
             $RMG_SITE_METADATA_DIR/run_rmg_$(date -d 'today' +'%Y.%m.%d_%H.%M').txt &"
        update_sitelist $SITE status active
      elif [[ $STATUS == "active" ]]; then
        echo "$SITE already running"
      else 
        echo "$SITE is currently down."
      fi 
    ;;

    stop) 
      echo "stop $SITE"
      if [[ $STATUS == "active" ]]
      then
        ssh -i $RMG_SERVER_SSH_KEYFILE rmg@$SITE '/usr/bin/killall run_rmg 2> /dev/null'
        udpate_sitelist $SITE status up
      else 
        echo "$SITE isn't running."
      fi 
    ;;

    fetch)
      if [[ $STATUS != "down" ]]
      then
        echo "fetch $SITE"
        DIRECTORIES_TO_COPY=$(ssh -i $RMG_SERVER_SSH_KEYFILE rmg@$SITE \ 
                      "cd $RMG_SITE_DET_DIR && find -type d" | rmg_fetch.py) # directories to copy
        mkdir -p $RMG_SERVER_DET_DIR/$SITE 
        ct=0
        for DIR in $DIRECTORIES_TO_COPY; do
          echo "copying $DIR"
          mkdir -p $RMG_SERVER_DET_DIR/$SITE/$DIR
          rsync -ave "ssh -i $RMG_SERVER_SSH_KEYFILE" rmg@$SITE:$RMG_SITE_DET_DIR/$DIR/* \ 
            $RMG_SERVER_DET_DIR/$SITE/$DIR                                        # download to RMG server
          ssh -i $RMG_SERVER_SSH_KEYFILE rmg@$SITE "rm -r $RMG_SITE_DET_DIR/$DIR" # delete from RMG remote
          let ct=ct+1
        done
        if [ $ct -eq 0 ]; then echo "Nothing to fetch."; fi
      else 
        echo "$SITE is currently down."
      fi
    ;;
    
    updatetx) 
      if [[ $STATUS != "down" ]]
      then
        echo "udpatetx $SITE"
        if [ -e $TX_FILE ]
        then
          scp -i $RMG_SERVER_SSH_KEYFILE $TX_FILE rmg@$SITE:$RMG_SITE_METADATA_DIR/tx.csv 
        else 
          echo "error: '$TX_FILE' doesn't exist"
        fi
      else 
        echo "$STIE is currently down."
      fi
    ;;
 
    cyclerx)
      if [[ $STATUS != "down" ]] 
      then
        echo "cyclerx $SITE" 
        # TODO
      else 
        echo "$SITE is currently down."
      fi
    ;;
    
  esac
  let count=count+1
done



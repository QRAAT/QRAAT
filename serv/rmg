#!/bin/bash
# rmg
# This script is part of the QRAAT system. It provides basic server
# side controls for RMG comptures/receiver running remotely. 
#
# Copyright (C) 2013 Christopher Patton
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Notes
# 
# Meta data (transmitter file, log files, etc.) is stored persistently on
# disk on the RMG remotes, typically in /home/rmg. Data (.det files, 
# status.txt) is written in memory to ramdisk, typically /tmp/ramdisk/det.
# 
# We make heavy use of SSH. To avoid entering passwords all the time, we 
# use an RSA encryption key with no passphrase. The public key is stored 
# at all RMG remote sites in /home/rmg/.ssh/authorized_keys; the private 
# key is kept at the server, typically /home/rmg/.ssh/rmg_rsa. This is 
#because the remotes run the SSH daemon. 
#
# Tasks 
# 
#  'up/down'
# 
# Power the physical hardware on and off. The relevant components are the 
# RMG receiver and the host computer, called the "RMG remote". The power
# supply for these will run through a network addressible hub. Theoretically,
# we should be able to tell this device to turn it sattached components on 
# and off. 
#     'up' does nothing special, but 'down' will SIGINT the run_rmg program 
# if it's running. Next, it sends the RMG remote the halt signal, waits a 
# sufficient amount of time (say 5 seconds), and powers the computer off. 
#     A list of up sites is stored in $(pwd)/up_sites. 
#
#  'start/stop'
# 
# Run and kill the pulse detector module (run_rmg). Output is logged in a 
# file in the meta data directory.
#
#  'fetch' 
#
# Download pulse data (.det files) from RMG remote to RMG server. Upon 
# success, erase the transfered data from the RMG remote. The pulse detector 
# in the RMG module emits .det files into a directory structure like 
# YYYY/MM/DD/HH/mm/ssuuuuuu.det. We want to be able to copy these files from 
# RMG remotes to the server, but exclude the directory that is being mutated. 
#       One solution would be to implement a hot-directory locking 
# mechanism on the RMG remote side. Since we don't want to burden the site 
# computers with this extra work, we decided to take advantage of the fact 
# that the real clock time must be synchronized across all nodes of the 
# network. We fetch all directories that are older than one minute because 
# the pulse detector will never mutate these directories again. 
#
#  'updatetx' 
#
# Update transmitter information on specified sites. This task includes an
# option to specify a file. 
#
#  'cyclerx'
#
# Cycle the power on the RMG module.  
#
# TODOs 
# 
# - Run task on 'all' sites. 
#
#

source rmg_env  # setup RMG environment variables

function help() {
  cat <<!EOF!
usage: rmg task [-options] {sites}/all  

  This program is part of the QRAAT system. It provides basic controls
  for RMG computers/receivers running in the field. Perform a batch job
  on a list of sites. If 'all' is provided, the job will be dispatched to 
  all up sites.   

  'task' is any one of the following:

    status       Show status of a site. 

    update       Update a site's *goal* state. (TEMP)

    up           Power on remote computer and RMG receiver. If no arguments
                 provided, print sites currently up. 

    down         Power off remote computer and RMG receiver. 

    start        Sart RMG software defined radio. Store pulse data remotely. 

    stop         Stop running RMG software defined radio. 

    fetch        Download pulse data from site to server. Delete downloaded 
                 data from remote machine. 
    
    updatetx --file FILE    Update transmitter file on remote computer. 
                            Defaults to 'tx.csv' in working directory.

    cyclerx      Power off the RMG receiver and power it back on.

    estimate     Process det files into est files from given site.

    help         Print this. 
!EOF!
}


## Configuration and status of sites ##
if [ $? -ne 0 ]; 
then
  echo "error: site configuration information not available (no sitelist.csv)." 1>&2
  exit 1
fi 


function update_sitelist () {
  SITE=$1
  ENTRY=$2
  VALUE=$3
  rmg_sitelist $SITE $ENTRY $VALUE < $RMG_SERVER_SITELIST > tmp.csv
  mv tmp.csv $RMG_SERVER_SITELIST
}

function get_sitelist() {
  SITE=$1
  ENTRY=$2
  rmg_sitelist $SITE $ENTRY < $RMG_SERVER_SITELIST
}


## Get task and options ##
TASK=$1 
shift

if [ ! $TASK ]
then
  help
  exit 0
fi

case $TASK in
 -h|--help|help)
   help
   exit 0
  ;; 

  updatetx)
    if [[ "$1" == "-f" ]] || [[ "$1" == "--file" ]] 
    then
      TX_FILE=$2
      shift
      shift
    else     
      TX_FILE="tx.csv"
    fi
  ;;

  status|update|up|down|start|stop|fetch|cyclerx|estimate)
  ;; 
    
  *)
    echo error: unrecognized task \'$TASK\'
    exit 1
  ;;

esac 


## Site list ##
SITES=$@


## Run tasks at each site ##
count=0
for SITE in $SITES
do

  STATUS=$(get_sitelist $SITE state)
  ADDR=$(get_sitelist $SITE comp_ip)
  if [ $? -ne 0 ]; then 
    echo "error: site '$SITE' not recognized." 1>&2
    exit 1
  fi 

  case $TASK in 
    status)
      # TODO
      echo "$SITE is $STATUS"
    ;;

    update)
      echo "update $SITE"
      rmg_sitelist --row $SITE <sitelist.csv >site.csv
      scp -i $RMG_SERVER_SSH_KEYFILE site.csv rmg@$ADDR:$RMG_SITE_METADATA_DIR/site.csv
      rm site.csv
    ;;

    up)
      echo -n "up $SITE "
      TYPE=$(get_sitelist $SITE powertype) 
      IP=$(get_sitelist $SITE power_ip)
      C_OUTLET=$(get_sitelist $SITE comp_outlet)
      R_OUTLET=$(get_sitelist $SITE rx_outlet)
      rmg_powerswitch $TYPE $IP $C_OUTLET ON && \
      rmg_powerswitch $TYPE $IP $R_OUTLET ON
      if [ $? -ne 0 ]; then
        echo "error: couldn't reach $ADDR." 1>&2
        exit 1
      else
        echo 
        update_sitelist $SITE state up
      fi
    ;; 

    down)
      echo -n "down $SITE "
      ssh -i $RMG_SERVER_SSH_KEYFILE rmg@$ADDR "/usr/bin/killall run_rmg 2> /dev/null; sudo /sbin/poweroff"
      sleep 5 # wait an appropriate time
      TYPE=$(get_sitelist $SITE powertype) 
      IP=$(get_sitelist $SITE power_ip)
      C_OUTLET=$(get_sitelist $SITE comp_outlet)
      R_OUTLET=$(get_sitelist $SITE rx_outlet)
      rmg_powerswitch $TYPE $IP $C_OUTLET OFF && \
      rmg_powerswitch $TYPE $IP $R_OUTLET OFF
      if [ $? -ne 0 ]; then
        echo "error: couldn't reach $ADDR." 1>&2
        exit 1
      else 
        echo         
        update_sitelist $SITE state down
      fi
    ;;
    
    start) 
      echo "start $SITE"
      # Start an RMG process on remote machine. Redirect all output to a 
      # timestamped log file. 
      if [[ $STATUS == "up" ]]
      then

        ssh -i $RMG_SERVER_SSH_KEYFILE rmg@$ADDR \
            "/usr/local/bin/run_rmg -d $RMG_SITE_DET_DIR \
             -f $RMG_SITE_METADATA_DIR/tx.csv \
             -p /dev/ttyUSB0 > \
             $RMG_SITE_METADATA_DIR/run_rmg_$(date -d 'today' +'%Y.%m.%d_%H.%M').txt \
             2> $RMG_SITE_METADATA_DIR/run_rmg_error.txt &"

        sleep 5

        if [ $(ssh -i $RMG_SERVER_SSH_KEYFILE rmg@$ADDR "pgrep run_rmg") ]
          then 
            update_sitelist $SITE state active
          else
            echo "error: RMG couldn't start." 1>&2
            echo "----------------------------------------" 1>&2
            ssh -i $RMG_SERVER_SSH_KEYFILE rmg@$ADDR "cat $RMG_SITE_METADATA_DIR/run_rmg_error.txt" 1>&2
            echo "----------------------------------------" 1>&2
          fi

      elif [[ $STATUS == "active" ]]; then
        echo "$SITE already running"

      else 
        echo "$SITE is currently down."
      fi 
    ;;

    stop) 
      echo "stop $SITE"
      ssh -i $RMG_SERVER_SSH_KEYFILE rmg@$ADDR '/usr/bin/killall run_rmg 2> /dev/null'
      # TODO if success, change status
      update_sitelist $SITE state up
    ;;

    fetch)
      if [[ $STATUS != "down" ]]
      then
        echo "fetch $SITE"
        DIRECTORIES_TO_COPY=$(ssh -i $RMG_SERVER_SSH_KEYFILE rmg@$ADDR "cd $RMG_SITE_DET_DIR \
          && find -type d" | rmg_fetch) # directories to copy
        mkdir -p $RMG_SERVER_DET_DIR/$SITE 
        ct=0
        for DIR in $DIRECTORIES_TO_COPY; do
          echo "copying $DIR"
          mkdir -p $RMG_SERVER_DET_DIR/$SITE/$DIR
          rsync -ave "ssh -i $RMG_SERVER_SSH_KEYFILE" rmg@$ADDR:$RMG_SITE_DET_DIR/$DIR/* \
            $RMG_SERVER_DET_DIR/$SITE/$DIR                                        # download to RMG server
          ssh -i $RMG_SERVER_SSH_KEYFILE rmg@$ADDR "rm -r $RMG_SITE_DET_DIR/$DIR" # delete from RMG remote
          let ct=ct+1
        done
        if [ $ct -eq 0 ]; then echo "Nothing to fetch."; fi
      else 
        echo "$SITE is currently down."
      fi
    ;;
    
    updatetx) 
      if [[ $STATUS != "down" ]]
      then
        echo "udpatetx $SITE"
        if [ -e $TX_FILE ]
        then
          scp -i $RMG_SERVER_SSH_KEYFILE $TX_FILE rmg@$ADDR:$RMG_SITE_METADATA_DIR/tx.csv 
        else 
          echo "error: '$TX_FILE' doesn't exist" 1>&2
        fi
      else 
        echo "$STIE is currently down."
      fi
    ;;
 
    cyclerx)
      if [[ $STATUS != "down" ]] 
      then
        echo "cyclerx $SITE" 
        TYPE=$(get_sitelist $SITE powertype) 
        IP=$(get_sitelist $SITE power_ip)
        R_OUTLET=$(get_sitelist $SITE rx_outlet)
        rmg_powerswitch $TYPE $IP $R_OUTLET CYCLE
      else 
        echo "$SITE is currently down."
      fi
    ;;
    
    estimate)
      echo "estimate $SITE"
      est_processing $RMG_SERVER_DET_DIR/$SITE/ $RMG_SERVER_EST_DIR/$SITE/
    ;;

  esac
  let count=count+1
done



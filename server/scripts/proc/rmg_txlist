#!/usr/bin/python2
# Thus far, this script will only create a valid tx.csv for pulse type 
# transmitters. We'll need to combine the parameter list for all transmitter
# types. 


import qraat, qraat.srv
import MySQLdb as mdb
import argparse


parser = argparse.ArgumentParser(description="Produce tx.csv file from database")
parser.add_argument("db_auth_file", help="Path to db_auth file")
parser.add_argument("-f", "--tx_file", help="Path to tx.csv file", default='./tx.csv')
parser.add_argument("-r", "--rise_trigger", type=float, help="Detector rise trigger", default=1.5)
parser.add_argument("-t", "--time_constant", type=float, help="Detector time constant", default=10)

args = parser.parse_args()

default_type = 'pulse'

db_con = qraat.srv.util.get_db('reader')

cur = db_con.cursor()

# Transmitters in active deployments
cur.execute('''SELECT deployment.ID, txID, frequency 
                 FROM deployment
                 JOIN tx ON tx.ID = txID
                 JOIN tx_make ON tx_make.ID = tx.tx_makeID
                WHERE is_active = True
                  AND demod_type = '%s' ''' % default_type)

tx_dict = {}
for (dep_id, tx_id, frequency) in cur.fetchall():
  tx_dict[tx_id] = { 'frequency' : frequency, 'dep_id' : dep_id }

# Transmitter parameters
cur.execute('''SELECT txID, name, value 
                 FROM tx_parameters
                WHERE txID IN (%s)''' % ', '.join(map(lambda(x) : str(x), 
                                  tx_dict.keys())))
              
for (tx_id, name, value) in cur.fetchall():
  tx_dict[tx_id][name] = value

header = ['ID', 'frequency', 'type', 'pulse_width', 'rise_trigger', 'time_constant']

data = []

for (tx_id, params) in tx_dict.iteritems():
  data.append((params['dep_id'], 
               float(params['frequency']), 
               default_type, 
               float(params['pulse_width']), 
               args.rise_trigger, 
               args.time_constant))

txlist = qraat.csv.csv()
txlist.initialize_from_data(header, data)
txlist.write(args.tx_file)

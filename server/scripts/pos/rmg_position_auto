#!/usr/bin/python
# TODO add timers for logging (e.g. see serv/proc/rmg_det_to_db) 
# TODO clean up output, as well as error handling in position.py.  

import qraat, qraat.srv
import numpy as np
import os, commands, sys

EST_SCORE_THRESHOLD = 0.15

(status, output) = commands.getstatusoutput(
  'pgrep -c `basename %s`' % (sys.argv[0]))
if int(output) > 1: 
  print >>sys.stderr, "position_auto: error: attempted reentry, exiting"
  sys.exit(1)


db_con = qraat.util.get_db('writer')
cursor = db_con.cursor()

# Get id of last processed record (last record scored). 
cursor.execute("SELECT value FROM qraat.cursor WHERE name='position'")
last_processed = cursor.fetchone()
if last_processed == None:
  cursor.execute("INSERT INTO qraat.cursor (name, value) VALUE ('position', 0)")
  last_processed = 0
else: 
  last_processed = last_processed[0]
print "Last EST record processed: {}".format(last_processed)

# Get deployments that have been scored but not processed. 
cursor.execute('''SELECT DISTINCT deploymentID 
                    FROM est JOIN estscore 
                      ON est.ID = estscore.estID
                   WHERE ID > %s;''', (last_processed,))
dep_list = cursor.fetchall()
print "{} transmitters found in new records".format(len(dep_list))
print dep_list
if len(dep_list) > 0:
  cal_id = int(os.environ['RMG_POS_CAL_ID'])
  sv = qraat.srv.position.steering_vectors(db_con, cal_id)
  center = qraat.srv.position.get_center(db_con)

time_window = float(os.environ['RMG_POS_TIME_WINDOW'])
time_delta = float(os.environ['RMG_POS_TIME_STEP'])
max_id = last_processed
for dep in dep_list:
  dep_id = dep[0]
  print "Processing transmitter: {}".format(dep_id)
  #get times of to-be-processed records
  cursor.execute('''SELECT ID, timestamp 
                      FROM est JOIN estscore
                        ON est.ID = estscore.estID
                     WHERE ID > %s AND deploymentID = %s 
                     ORDER BY timestamp ASC;''', (last_processed,dep_id))
  times = np.array(cursor.fetchall(),dtype=float)
  print "Found {} records".format(times.shape[0])
  print "Calculating time range"
  #determine time range needed to be processed
  #TODO source rmg_env
  time_ranges = []
  if times.shape[0] > 0:
    temp_range = [times[0,1], times[0,1]]
    for j in range(1,times.shape[0]):
      if times[j,1] - time_window < temp_range[1] + time_window:
        temp_range[1] = times[j,1]
      else:
        time_ranges.append(temp_range)
        temp_range = [times[j,1], times[j,1]]
    time_ranges.append(temp_range)
  #TODO combine close ranges?

  
 #process time ranges
  for time_range in time_ranges:
    print "Processing {0} - {1}".format(time_range[0],time_range[1])
    
    est_ids = qraat.srv.position.get_est_ids_timefilter(db_con, 
                                                    dep_id, 
                                                    time_range[0]-time_window, 
                                                    time_range[1]+time_window, 
                                                    EST_SCORE_THRESHOLD)
    
    sig = qraat.srv.position.signal(db_con, est_ids)
    
    if len(sig) == 0: 
      print "Skipping empty chunk"
      continue 
    
    bl = qraat.srv.position.position_estimator(sv, sig)
    (utm_zone_letter, utm_zone_number) = bl.get_utm_zone()
    
    (bearing, position)  = qraat.srv.position.calc_positions(sig, bl, 
                                                         center,
                                                         utm_zone_letter,
                                                         utm_zone_number,
                                                         time_window, 
                                                         time_delta,
                                                         dep_id)
    bearing.insert_db(db_con)
    position.insert_db(db_con)

  temp_max_id = np.max(times[:,0])
  if temp_max_id > max_id:
    max_id = temp_max_id

#store id of last processed record
if max_id > last_processed:
  cursor.execute("UPDATE qraat.cursor SET value=%s WHERE name='position'", (max_id,))

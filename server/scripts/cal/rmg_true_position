#!/usr/bin/python
# rmg_true_position
# Interpolate GPS and pulse data for a calibration run and calculate 
# a bearing for each time indexed pulse per site. Inputs from 
# qraat.GPS_Calibration_Data and qraat.est, outputs to 
# qraat.True_Position. This program is part of QRAAT, an automated 
# animal tracking system based on GNU Radio. 
#
# In any case, the resulting bearing seems to be consistent. 
#
# Copyright (C) 2013 Todd Borrowman, Christopher Patton
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import qraat
import time, os, sys
import numpy as np
#import MySQLdb as mdb
from optparse import OptionParser

parser = OptionParser()

parser.description = '''\
Interpolate GPS and pulse data and calculate a bearing for each 
time indexed pulse per site for a calibration run. This program is part of
QRAAT, an automated animal tracking system based on GNU Radio.   
'''

parser.add_option('--dep-id', type='int', metavar='INT',
                  help="Deployment ID, the serial identifier in the database "
                       "context identifying a calibration run.")

(options, args) = parser.parse_args()

if options.dep_id == None:
  print >>sys.stderr, "true_position: erorr: need to provide a deployment ID via `--dep-id`."
  sys.exit(1)

# Get database credentials.
db_con = qraat.util.get_db('writer')


start = time.time()
print "true_position: start time:", time.asctime(time.localtime(start))

# Connect to the database. 
cur = db_con.cursor()

# Get GPS data for calibration run. 
if not cur.execute("SELECT timestamp, easting, northing FROM gps_data WHERE deploymentID = %s", options.dep_id):
  print >>sys.stderr, "true_position: error: no GPS data found for specified deployment."
  sys.exit(1)

gps_data = np.array(cur.fetchall(), dtype=float)
gps_timestamp = gps_data[:,0]
gps_easting = gps_data[:,1]
gps_northing = gps_data[:,2]

# Get start and end times. 
(t_start, t_end) = min(gps_data[:,0]), max(gps_data[:,0])

print "true_position: getting site data"
cur.execute("SELECT ID, easting, northing from site")
site_data = np.array(cur.fetchall(), dtype=float)

print "true_position: getting est data ..."
cur.execute('''SELECT timestamp, ID, siteid 
                   FROM est 
                  WHERE deploymentID=%s 
                    AND timestamp >= %s 
                    AND timestamp <= %s''',(options.dep_id, t_start, t_end))

est_data = np.array(cur.fetchall(), dtype=float)
ct = est_data.shape[0]
est_timestamp = est_data[:,0]
est_ID = est_data[:,1]
est_siteid = est_data[:,2]
print "processing %d records." % ct

if ct > 0: 

  # calculate pulse position from time, linear interpolation 
  est_easting = np.interp(est_timestamp, gps_timestamp, gps_easting)
  est_northing = np.interp(est_timestamp, gps_timestamp, gps_northing)

  site_mask = np.where(est_siteid == site_data[:,0])
  site_easting = site_data[site_mask,1]
  site_northing = site_data[site_mask,2]

  # Calculate pulse bearing
  est_bearing = np.arctan2(est_easting - site_easting, 
                           est_northing - site_northing)*180/np.pi

  # Insert into databse. 
  cur.executemany('''INSERT INTO true_position 
                            (estID, easting, northing, bearing) 
                     VALUES (%s, %s, %s, %s)''', 
         [ (est_ID[j], est_easting[j], 
            est_northing[j], est_bearing[j]) for j in range(ct) ])


print "true_position: finished in %.2f seconds." % (time.time() - start)
